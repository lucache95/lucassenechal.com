---
phase: 01-foundation-landing-page
plan: 03
type: execute
wave: 2
depends_on: [01-01]
files_modified:
  - app/actions.ts
  - components/landing/hero.tsx
  - components/landing/sticky-cta.tsx
autonomous: true
requirements: [SITE-03, SITE-07]

user_setup:
  - service: supabase
    why: "Database for subscriber storage"
    env_vars:
      - name: NEXT_PUBLIC_SUPABASE_URL
        source: "Supabase Dashboard -> Project Settings -> API -> Project URL"
      - name: NEXT_PUBLIC_SUPABASE_ANON_KEY
        source: "Supabase Dashboard -> Project Settings -> API -> anon/public key"
      - name: SUPABASE_SERVICE_ROLE_KEY
        source: "Supabase Dashboard -> Project Settings -> API -> service_role key"
    dashboard_config:
      - task: "Create a new Supabase project (or use existing)"
        location: "https://supabase.com/dashboard"
      - task: "Run the SQL migration from supabase/migrations/001_subscribers.sql in the SQL Editor"
        location: "Supabase Dashboard -> SQL Editor"
  - service: railway
    why: "Hosting and deployment"
    env_vars: []
    dashboard_config:
      - task: "Create Railway project and link to GitHub repo"
        location: "https://railway.app/dashboard"
      - task: "Add environment variables (NEXT_PUBLIC_SUPABASE_URL, NEXT_PUBLIC_SUPABASE_ANON_KEY, SUPABASE_SERVICE_ROLE_KEY)"
        location: "Railway Dashboard -> Project -> Variables"
      - task: "Configure custom domain lucassenechal.com"
        location: "Railway Dashboard -> Project -> Settings -> Domains"
  - service: domain-dns
    why: "Custom domain with HTTPS and email authentication"
    env_vars: []
    dashboard_config:
      - task: "Point lucassenechal.com DNS to Railway (CNAME or A record)"
        location: "Domain registrar DNS settings"
      - task: "Add SPF record: v=spf1 include:resend.com ~all"
        location: "Domain registrar DNS settings"
      - task: "Add DKIM record (get value from Resend dashboard after adding domain)"
        location: "Domain registrar DNS settings"
      - task: "Add DMARC record: v=DMARC1; p=none; rua=mailto:dmarc@lucassenechal.com"
        location: "Domain registrar DNS settings"
  - service: resend
    why: "Email sending and domain authentication"
    env_vars:
      - name: RESEND_API_KEY
        source: "Resend Dashboard -> API Keys -> Create API Key"
    dashboard_config:
      - task: "Add and verify lucassenechal.com domain in Resend"
        location: "Resend Dashboard -> Domains -> Add Domain"
      - task: "Copy DKIM DNS records from Resend to domain registrar"
        location: "Resend Dashboard -> Domains -> lucassenechal.com"

must_haves:
  truths:
    - "Visitor can enter email and click 'Start free' to subscribe"
    - "Valid email is stored in Supabase subscribers table with 'pending' status"
    - "Duplicate email shows friendly error, not crash"
    - "Invalid email shows validation error"
    - "Both hero form and sticky CTA form work identically"
  artifacts:
    - path: "app/actions.ts"
      provides: "Server Action for email subscription"
      exports: ["subscribeEmail"]
    - path: "components/landing/hero.tsx"
      provides: "Hero with working email capture form"
      contains: "subscribeEmail"
    - path: "components/landing/sticky-cta.tsx"
      provides: "Sticky CTA with working email capture form"
      contains: "subscribeEmail"
  key_links:
    - from: "components/landing/hero.tsx"
      to: "app/actions.ts"
      via: "Server Action form binding"
      pattern: "subscribeEmail"
    - from: "app/actions.ts"
      to: "lib/supabase/server.ts"
      via: "database insert"
      pattern: "createClient.*from.*subscribers.*insert"
    - from: "components/landing/sticky-cta.tsx"
      to: "app/actions.ts"
      via: "Server Action form binding"
      pattern: "subscribeEmail"
---

<objective>
Wire the email capture forms to a Server Action that validates and stores subscriber emails in Supabase. This turns the landing page from static to functional — visitors can actually subscribe.

Purpose: Email capture is the primary conversion goal of the landing page. Without this, the page is a brochure. With it, every visitor is a potential subscriber.
Output: Working email capture flow from form submission to Supabase storage, with validation and error handling.
</objective>

<execution_context>
@/Users/lucassenechal/.claude/get-shit-done/workflows/execute-plan.md
@/Users/lucassenechal/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-landing-page/01-RESEARCH.md
@.planning/phases/01-foundation-landing-page/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create email subscription Server Action with validation</name>
  <files>
    app/actions.ts
  </files>
  <action>
    Create the Server Action that handles email capture from both the hero and sticky CTA forms.

    **app/actions.ts:**

    ```typescript
    'use server'
    ```

    Create `subscribeEmail` function:

    1. **Input:** Accept `FormData` with an `email` field
    2. **Validation:**
       - Check email is a non-empty string
       - Validate email format using a regex or built-in pattern (keep it simple — `/^[^\s@]+@[^\s@]+\.[^\s@]+$/`)
       - Return `{ error: 'Please enter a valid email address' }` on invalid
    3. **Supabase insert:**
       - Use `createClient()` from `@/lib/supabase/server`
       - Insert into `subscribers` table: `{ email, status: 'pending', created_at: new Date().toISOString() }`
    4. **Error handling:**
       - Catch Postgres unique violation (error code `23505`): return `{ error: 'This email is already subscribed!' }`
       - Catch all other errors: return `{ error: 'Something went wrong. Please try again.' }`
       - Log the actual error to console for debugging (server-side only, not exposed to client)
    5. **Success:** Return `{ success: true }`

    Return type: `Promise<{ success?: boolean; error?: string }>`

    **Important:** Do NOT use zod for validation here — it's an unnecessary dependency for a single email field. Keep it minimal. We'll add zod in Phase 2 when the signup flow has multiple fields.
  </action>
  <verify>
    Run `npm run build` to confirm the Server Action compiles. Check that the file has `'use server'` directive at the top. Verify it imports `createClient` from `@/lib/supabase/server`. If Supabase is configured with real credentials, test manually by submitting the form — check the subscribers table in Supabase dashboard.
  </verify>
  <done>
    Server Action `subscribeEmail` exists at `app/actions.ts`, validates email format, inserts into Supabase `subscribers` table, handles duplicates gracefully, and returns typed success/error response.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire email capture forms to Server Action with UX states</name>
  <files>
    components/landing/hero.tsx
    components/landing/sticky-cta.tsx
  </files>
  <action>
    Update both email capture forms to use the `subscribeEmail` Server Action with proper UX feedback.

    **components/landing/hero.tsx** — Update the hero email form:

    1. Import `subscribeEmail` from `@/app/actions`
    2. Use `useActionState` (from `react`) to manage form state:
       - `state`: holds the result `{ success?, error? }`
       - `formAction`: the bound action to pass to the form
       - `isPending`: true while the action is executing
    3. **States:**
       - Idle: Normal form with email input + "Start free" button
       - Loading (isPending): Button text changes to "Subscribing..." with disabled state and subtle opacity
       - Success (state.success): Hide form, show success message — "You're in! Check your inbox." with a checkmark animation (Framer Motion fade-in)
       - Error (state.error): Show error message below the form in red text, form remains usable
    4. The email input should have `type="email"` and `required` attributes for native browser validation as a first line of defense
    5. On success, optionally add `confetti` or a simple celebratory micro-animation (Framer Motion scale + opacity)

    **components/landing/sticky-cta.tsx** — Update the sticky CTA form:

    1. Same pattern as hero: import `subscribeEmail`, use `useActionState`
    2. States: idle, loading, success (collapse the bar or show compact success message), error (show inline)
    3. The sticky bar form is more compact — horizontal layout: `[email input] [Start free button]`
    4. On success, the sticky bar can smoothly collapse or show "Subscribed!" text

    **Both forms must:**
    - Share the same `subscribeEmail` action
    - Work independently (subscribing via hero doesn't affect sticky bar state and vice versa)
    - Have proper `name="email"` on the input field
    - Clear the input on error so user can re-enter
  </action>
  <verify>
    Run `npm run dev`. Test email capture in hero form: (1) Submit empty — browser validation blocks. (2) Submit invalid email — browser validation or server error shows. (3) Submit valid email — see loading state, then success message. Test sticky CTA form with same sequence. Verify both forms work independently. If Supabase is connected, check that the email appears in the subscribers table.
  </verify>
  <done>
    Both hero and sticky CTA email capture forms are wired to the subscribeEmail Server Action. Forms show loading state during submission, success message with animation on subscribe, and error messages for invalid or duplicate emails. Both forms work independently.
  </done>
</task>

</tasks>

<verification>
1. `app/actions.ts` exports `subscribeEmail` Server Action
2. Hero form submits to `subscribeEmail` and shows success/error states
3. Sticky CTA form submits to `subscribeEmail` and shows success/error states
4. Duplicate email submission shows "already subscribed" error
5. Invalid email shows validation error
6. Successful submission stores email in Supabase with 'pending' status
7. `npm run build` succeeds
</verification>

<success_criteria>
- Email capture works end-to-end: form submission -> validation -> Supabase insert -> success feedback
- Both hero and sticky CTA forms use the same Server Action
- Proper error handling for duplicates and invalid emails
- Smooth UX transitions between idle/loading/success/error states
- No secrets exposed to client (Supabase insert uses server-side client)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-landing-page/01-03-SUMMARY.md`
</output>
